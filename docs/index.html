<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pension Finance – Ucase1 (WebR)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Arial,sans-serif;max-width:900px;margin:2rem auto;padding:0 1rem}
    h1{font-size:1.4rem;margin-bottom:0.5rem}
    .row{display:flex;gap:1rem;flex-wrap:wrap;margin:0.5rem 0}
    label{display:flex;flex-direction:column;font-size:0.9rem}
    input{padding:0.4rem;border:1px solid #ccc;border-radius:6px;min-width:140px}
    button{padding:0.6rem 1rem;border:0;border-radius:8px;cursor:pointer;box-shadow:0 1px 3px rgba(0,0,0,.1)}
    pre{background:#f7f7f9;padding:0.8rem;border-radius:8px;overflow:auto}
    .card{border:1px solid #eee;border-radius:12px;padding:1rem}
  </style>
</head>
<body>
  <h1>Pension Finance – Ucase1 (WebR, no server)</h1>

  <div class="card">
    <div class="row">
      <label>Rate (per period)
        <input id="rate" type="number" step="0.0001" value="0.02">
      </label>
      <label>Periods (nper)
        <input id="nper" type="number" step="1" value="10">
      </label>
      <label>Present Value (pv)
        <input id="pv" type="number" step="0.01" value="10000">
      </label>
    </div>
    <div class="row">
      <button id="run">Compute</button>
    </div>
    <div class="row">
      <div><strong>Future Value:</strong> <span id="fv">—</span></div>
    </div>
    <div class="row" style="margin-top:1rem">
      <canvas id="chart" height="120"></canvas>
    </div>
  </div>

  <h3>Debug output</h3>
  <pre id="out">Waiting…</pre>
  
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script type="module">
  const out = document.getElementById("out");
  const fvSpan = document.getElementById("fv");
  const ctx = document.getElementById("chart").getContext("2d");
  let chart;

  function log(msg, obj) {
    out.textContent =
      (typeof msg === "string" ? msg : JSON.stringify(msg, null, 2)) +
      (obj ? "\n" + JSON.stringify(obj, null, 2) : "");
  }

  import { WebR } from "https://webr.r-wasm.org/latest/webr.mjs";
  const webR = new WebR();

  // unwrap WebR objects → plain JS
  function unwrap(x) {
    if (x == null || typeof x !== "object") return x;
    if (x.type === "list") {
      const o = {};
      (x.names || []).forEach((k, i) => (o[k] = unwrap(x.values[i])));
      return o;
    }
    if (Array.isArray(x.values)) {
      return x.values.length === 1 ? unwrap(x.values[0]) : x.values.map(unwrap);
    }
    return x;
  }

  function buildPathFromInputs(rate, nper, pv) {
    const t = Array.from({ length: nper + 1 }, (_, i) => i);
    const path = t.map(i => pv * Math.pow(1 + rate, i));  // positive FV path
    return { t, path, fv: path[path.length - 1] };
  }

  async function init() {
    log("Starting WebR…");
    await webR.init();
    const resp = await fetch("./r/ucase1.R");
    if (!resp.ok) throw new Error(`Could not fetch r/ucase1.R (${resp.status})`);
    const code = await resp.text();
    await webR.evalR(code);
    log("WebR ready. ucase1() loaded.");

    chart = new Chart(ctx, {
      type: "line",
      data: { labels: [], datasets: [{ label: "Future Value path", data: [], tension: 0.15, pointRadius: 0 }] },
      options: {
        responsive: true, maintainAspectRatio: false,
        scales: {
          x: { title: { display: true, text: "Period (t)" } },
          y: { title: { display: true, text: "Value" }, ticks: { callback: v => v.toLocaleString() } }
        },
        plugins: { legend: { display: false } }
      }
    });
  }

  function updateChart(t, path) {
    chart.data.labels = t;
    chart.data.datasets[0].data = path;
    chart.update();
  }

  async function runOnce() {
    try {
      const rate = parseFloat(document.getElementById("rate").value);
      const nper = parseInt(document.getElementById("nper").value, 10);
      const pv   = parseFloat(document.getElementById("pv").value);

      const rObj = await webR.evalR(`ucase1(rate=${rate}, nper=${nper}, pv=${pv})`);
      const raw  = await rObj.toJs();
      const js   = unwrap(raw);

      // Try to read R-provided path; otherwise build it from inputs
      const fvFromR  = js?.results?.fv;
      const tFromR   = js?.results?.t?.values ?? js?.results?.t;
      const pathFromR= js?.results?.fv_path?.values ?? js?.results?.fv_path;

      let fv, t, path;
      if (Array.isArray(tFromR) && Array.isArray(pathFromR)) {
        fv   = typeof fvFromR === "number" ? fvFromR : pathFromR[pathFromR.length - 1];
        t    = tFromR;
        path = pathFromR;
      } else {
        ({ fv, t, path } = buildPathFromInputs(rate, nper, pv));
      }

      fvSpan.textContent = fv.toFixed(2);
      updateChart(t, path);
      log(js);
    } catch (e) {
      fvSpan.textContent = "n/a";
      log("Run error: " + (e?.message || e));
    }
  }

  document.getElementById("run").addEventListener("click", runOnce);
  await init();
  await runOnce();
</script>

</body>
</html>
